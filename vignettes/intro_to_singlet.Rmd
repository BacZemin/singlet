---
title: "NMF-based Single-cell Analysis"
author: "Zach DeBruine"
date: "6/13/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Set up the Seurat Object

This tutorial introduces guided clustering and basic gene set enrichment analysis using `singlet`. It uses the `SeuratData::pbmc3k` dataset and overlaps with the Seurat introductory tutorial on [guided clustering] (satijalab.org/seurat/articles/pbmc3k_tutorial.html) using the `SeuratData::pbmc3k` dataset.

```{R, message = FALSE, warning = FALSE}
library(singlet)
library(Seurat)
library(SeuratData)
SeuratData::InstallData("pbmc3k")
data(pbmc3k)
pbmc3k
```

## QC and selecting cells for further analysis

Remove doublets, very low-quality cells, but do not regress out mitochondrial genes. NMF will deal with systematic technical signal or noise, and regression of any form will hurt downstream analysis.

In general, NMF requires far less "data cleaning" than PCA.

```{R}
pbmc3k[["percent.mt"]] <- PercentageFeatureSet(pbmc3k, pattern = "^MT-")

pbmc3k <- subset(pbmc3k, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
```

## Normalize Data

Here we apply standard log-normalization, which works very well, but any form of approximate variance stabilizing transformation is suitable for helping NMF find meaningful solutions. Raw counts are not suitable for NMF.

```{R}
pbmc3k <- NormalizeData(pbmc3k, verbose = FALSE)
```

## Run NMF

NMF can be run on all features using normalized counts. `RunNMF` will automatically run cross-validation on an array of ranks that you provide, identify the best rank, and learn a model at that rank. 

Cross-validation can be taken some time. It is useful to start with a coarse-grained scan of a wide range of ranks and then focus on a narrow window of ranks with several replicates. `RunNMF` can also be run efficiently on a multi-threaded HPC node.

```{R, message = FALSE, warning = FALSE, eval = FALSE}
set.seed(123)
pbmc3k <- RunNMF(pbmc3k, k = seq(5, 25, 1), n_replicates = 3, precision = "double", verbose = 1)
RankPlot(pbmc3k)
```

A good model has already been learned at the optimal rank, but we may wish to learn a still higher-quality model:

```{R, message = FALSE, warning = FALSE}
pbmc3k <- RunNMF(pbmc3k, k = 15, tol = 1e-6, precision = "double", verbose = FALSE)
```

## Visualization

Plot the representation of various metadata (i.e. Seurat-annotated cell types) in each factor:

```{R}
MetadataPlot(pbmc3k, "seurat_annotations", reduction = "nmf")
```

Here we simply do what the Seurat Guided Clustering tutorial does, but for NMF:

```{R}
VizDimLoadings(pbmc3k, dims = 1:2, reduction = "nmf")
```

## Gene Set Enrichment Analysis

singlet makes GSEA with `fgsea` and `msigdbr` easy. Simply, the weights in the NMF "w" matrix are used as rankings for terms in the enrichment analysis.

```{R}
pbmc3k <- RunGSEA(pbmc3k, reduction = "nmf", category = "C5")

GSEAHeatmap(pbmc3k, reduction = "nmf", max.terms.per.factor = 3)
```

## Plotting NMF Factors

Because NMF factors are additive signals, we can also visualize their representation on UMAP coordinates:

```{R}
FeaturePlot(pbmc3k, features = paste0("NMF_", 1:9))
```

## Cell Clustering

The `pbmc3k` dataset comes with clusters that have been determined by graph-based clustering on a PCA embedding, followed by expert annotation. 

We will determine clusters by graph-based clustering on an NMF embedding, and then compare them to those PCA-guided clusters.

```{R, message = FALSE, warning = FALSE}
pbmc3k <- FindNeighbors(pbmc3k, dims = 1:ncol(pbmc3k@reductions$nmf), reduction = "nmf") %>%
  FindClusters(resolution = 0.5) %>%
  RunUMAP(reduction = "nmf", dims = 1:ncol(pbmc3k@reductions$nmf))
```

Compare the composition of NMF clusters to Seurat PCA-determined clusterings:

```{R}
df <- data.frame(
  "nmf_clusters" = pbmc3k@meta.data$seurat_clusters,
  "pca_clusters" = pbmc3k@meta.data$seurat_annotations)

df <- df[!is.na(df$pca_clusters), ]

df <- df %>% 
  group_by(nmf_clusters) %>% 
  count(pca_clusters) %>% 
  mutate(freq = n / sum(n))

ggplot(df, aes(nmf_clusters, pca_clusters, size = freq, color = n)) + 
  geom_point() + 
  theme_bw() + 
  labs(x = "NMF cluster", 
       y = "PCA cluster", 
       size = "proportion\nof cluster", 
       color = "cells in\nNMF cluster") + 
  scale_color_viridis_c(option = "D")
```

Since there is significant overlap between PCA- and NMF-guided clusters, we can just transfer the labels based on majority overlap:

```{R}
cluster_names <- df %>% 
  slice(which.max(n)) %>% 
  pull(pca_clusters)

levels(pbmc3k@meta.data$seurat_clusters) <- make.unique(as.vector(cluster_names))

DimPlot(pbmc3k, reduction = "umap", label = TRUE, group.by = "seurat_clusters", pt.size = 0.5) + NoLegend()
```

Compared to the PCA clustering, the NMF clustering more completely resolves NK cells, identifies two subpopulations of CD14+ Monocytes, and better resolves CD8 T-cells from Memory CD4 T-cells, but does not identify a small cluster of Dendritic Cells annotated in the Seurat vignette. These results show how PCA and NMF can be used to achieve very similar results for cell clustering.