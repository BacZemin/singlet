[{"path":"/articles/Batch_Integration_with_Singlet.html","id":"get-started","dir":"Articles","previous_headings":"","what":"Get Started","title":"Batch Integration with Singlet","text":"Use Seurat ifnb dataset:","code":"library(Seurat) library(ggplot2) library(singlet) library(SeuratData) library(cowplot) data(ifnb) ifnb <- NormalizeData(ifnb, verbose = FALSE)"},{"path":"/articles/Batch_Integration_with_Singlet.html","id":"determine-nmf-rank","dir":"Articles","previous_headings":"","what":"Determine NMF Rank","title":"Batch Integration with Singlet","text":"First determine number factors using cross-validation. can intensive start course-grained search get idea, zero-replicates. Note use split.= \"stim\", indicating “stim” field meta.data slot Seurat object factor giving discrete groupings samples (either stimulated unstimulated). RunNMF function weight samples groups equally NMF objective, regardless whether groups equal size.","code":"set.seed(123) ifnb <- RunNMF(ifnb, split.by = \"stim\", k = 10:35, n_replicates = 3, verbose = FALSE) ##  ## fitting final model: RankPlot(ifnb)"},{"path":"/articles/Batch_Integration_with_Singlet.html","id":"run-joint-nmf","dir":"Articles","previous_headings":"","what":"Run Joint NMF","title":"Batch Integration with Singlet","text":"Now learn really good model optimal rank: Visualize contribution groups factors:  factors almost exclusively explaining signal one dataset, .","code":"set.seed(123) ifnb <- RunNMF(ifnb, k = 24, tol = 1e-5, verbose = FALSE) MetadataPlot(ifnb, split.by = \"stim\", reduction = \"nmf\")"},{"path":"/articles/Batch_Integration_with_Singlet.html","id":"run-linked-nmf","dir":"Articles","previous_headings":"","what":"Run Linked NMF","title":"Batch Integration with Singlet","text":"Linked NMF uncouple sample groups factors weakly represented. LNMF initialized joint NMF model trained , just specify cutoff minimum fractional representation sample group given factor uncoupled factor. LNMF creates new reduction Seurat object, lnmf. Now examine group represented NMF factors:  can visualize models UMAP coordinates using joint model, entire linked NMF model, linked NMF model using shared factors:","code":"ifnb <- RunLNMF(ifnb, split.by = \"stim\", reduction.use = \"nmf\", link.cutoff = 0.5, tol = 1e-5, link.balance.rate = 0, verbose = FALSE) MetadataPlot(ifnb, split.by = \"stim\", reduction = \"lnmf\") ifnb <- RunUMAP(ifnb, reduction = \"nmf\", dims = 1:ncol(ifnb@reductions$nmf), reduction.name = \"jnmf_all\", verbose = FALSE) ifnb <- RunUMAP(ifnb, reduction = \"lnmf\", dims = 1:ncol(ifnb@reductions$lnmf), reduction.name = \"lnmf_all\", verbose = FALSE) ifnb <- RunUMAP(ifnb, reduction = \"lnmf\", dims = GetSharedFactors(ifnb, split.by = \"stim\"), reduction.name = \"lnmf_shared\", verbose = FALSE) selected_factors <-  which(rowSums(ifnb@reductions$lnmf@misc$link_matrix == 0) == 0) ifnb <- RunUMAP(ifnb, reduction = \"nmf\", dims = selected_factors, reduction.name = \"jnmf_shared\") p_jnmf_umap <- DimPlot(ifnb, reduction = \"jnmf_all\", group.by = \"stim\") p_jnmf_shared_umap <- DimPlot(ifnb, reduction = \"jnmf_shared\", group.by = \"stim\") p_lnmf_all_umap <- DimPlot(ifnb, reduction = \"lnmf_all\", group.by = \"stim\") p_lnmf_shared_umap <- DimPlot(ifnb, reduction = \"lnmf_shared\", group.by = \"stim\")"},{"path":"/articles/Batch_Integration_with_Singlet.html","id":"visualize","dir":"Articles","previous_headings":"","what":"Visualize","title":"Batch Integration with Singlet","text":"Plot results:","code":"plot_grid(plot_grid(   p_jnmf_umap + ggtitle(\"joint NMF\") + theme(legend.position = \"none\") + theme(legend.position = \"none\"),    p_jnmf_shared_umap + ggtitle(\"joint NMF, selected factors\") + theme(legend.position = \"none\"),    p_lnmf_all_umap + ggtitle(\"linked NMF, all factors\") + theme(legend.position = \"none\"),    p_lnmf_shared_umap + ggtitle(\"linked NMF, shared factors\") + theme(legend.position = \"none\"),    nrow = 2, ncol = 2  ), get_legend(p_jnmf_umap), ncol = 2, rel_widths = c(1, 0.2))"},{"path":"/articles/Guided_Clustering_with_NMF.html","id":"set-up-the-seurat-object","dir":"Articles","previous_headings":"","what":"Set up the Seurat object","title":"Guided Clustering with NMF","text":"vignette introduces guided clustering basic gene set enrichment analysis using singlet Seurat. uses SeuratData::pbmc3k dataset overlaps Seurat introductory tutorial [guided clustering] (satijalab.org/seurat/articles/pbmc3k_tutorial.html) using SeuratData::pbmc3k dataset.","code":"library(singlet) library(Seurat) library(SeuratData) library(dplyr) library(ggplot2) SeuratData::InstallData(\"pbmc3k\") data(pbmc3k) pbmc3k ## An object of class Seurat  ## 13714 features across 2700 samples within 1 assay  ## Active assay: RNA (13714 features, 0 variable features)"},{"path":"/articles/Guided_Clustering_with_NMF.html","id":"qc-and-selecting-cells-for-further-analysis","dir":"Articles","previous_headings":"","what":"QC and selecting cells for further analysis","title":"Guided Clustering with NMF","text":"Remove doublets, low-quality cells, regress mitochondrial genes. NMF deal systematic technical signal noise, regression form hurt downstream analysis. general, NMF requires far less “data cleaning” PCA.","code":"pbmc3k[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc3k, pattern = \"^MT-\")  pbmc3k <- subset(pbmc3k, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)"},{"path":"/articles/Guided_Clustering_with_NMF.html","id":"normalize-data","dir":"Articles","previous_headings":"","what":"Normalize Data","title":"Guided Clustering with NMF","text":"apply standard log-normalization, works well, form approximate variance stabilizing transformation suitable helping NMF find meaningful solutions. Raw counts suitable NMF. use Seurat::SCTransform NMF. Adding residuals negative binomial fits count data good idea additive decompositions. NMF smooth noise impute missing signal without help (opposed PCA fits missing signal, therefore benefits SCTransform).","code":"pbmc3k <- NormalizeData(pbmc3k, verbose = FALSE)"},{"path":"/articles/Guided_Clustering_with_NMF.html","id":"run-nmf","dir":"Articles","previous_headings":"","what":"Run NMF","title":"Guided Clustering with NMF","text":"NMF can run features using normalized counts. RunNMF automatically run cross-validation array ranks provide, identify best rank, learn model rank. Cross-validation can take time. large datasets, useful start coarse-grained scan wide range ranks focus narrow window ranks several replicates. Remember optimal number NMF factors analysis may significantly greater number PCA components might used. great step run High Performance Computing node.  Remember set seed, , guarantee reproducibility NMF model. good model already learned optimal rank, may wish learn still higher-quality model:","code":"set.seed(123) pbmc3k <- singlet::RunNMF(pbmc3k, k = 5:20, n_replicates = 2, verbose = FALSE) ##  ## fitting final model: RankPlot(pbmc3k) set.seed(123) pbmc3k <- RunNMF(pbmc3k, k = 15, tol = 1e-6, verbose = FALSE)"},{"path":"/articles/Guided_Clustering_with_NMF.html","id":"visualization","dir":"Articles","previous_headings":"","what":"Visualization","title":"Guided Clustering with NMF","text":"Plot representation various metadata (.e. Seurat-annotated cell types) factor:  simply Seurat Guided Clustering tutorial , NMF:","code":"MetadataPlot(pbmc3k, \"seurat_annotations\", reduction = \"nmf\") VizDimLoadings(pbmc3k, dims = 1:2, reduction = \"nmf\")"},{"path":"/articles/Guided_Clustering_with_NMF.html","id":"gene-set-enrichment-analysis","dir":"Articles","previous_headings":"","what":"Gene Set Enrichment Analysis","title":"Guided Clustering with NMF","text":"singlet makes GSEA fgsea msigdbr easy. Simply, weights NMF “w” matrix used rankings terms enrichment analysis.","code":"pbmc3k <- RunGSEA(pbmc3k, reduction = \"nmf\", category = \"C7\") ## Formal class 'DimReduc' [package \"SeuratObject\"] with 9 slots   ##   ..@ cell.embeddings           : num [1:2638, 1:15] 0.000524 0 0.000452 0 0 ...   ##   .. ..- attr(*, \"dimnames\")=List of 2   ##   .. .. ..$ : chr [1:2638] \"AAACATACAACCAC\" \"AAACATTGAGCTAC\" \"AAACATTGATCAGC\" \"AAACCGTGCTTCCG\" ...   ##   .. .. ..$ : chr [1:15] \"NMF_1\" \"NMF_2\" \"NMF_3\" \"NMF_4\" ...   ##   ..@ feature.loadings          : num [1:13714, 1:15] 0 0 0 0 0 ...   ##   .. ..- attr(*, \"dimnames\")=List of 2   ##   .. .. ..$ : chr [1:13714] \"AL627309.1\" \"AP006222.2\" \"RP11-206L10.2\" \"RP11-206L10.9\" ...   ##   .. .. ..$ : chr [1:15] \"NMF_1\" \"NMF_2\" \"NMF_3\" \"NMF_4\" ...   ##   ..@ feature.loadings.projected: num[0 , 0 ]    ##   ..@ assay.used                : chr \"RNA\"   ##   ..@ global                    : logi(0)    ##   ..@ stdev                     : num [1:15] 571835 418629 375066 329047 326267 ...   ##   ..@ key                       : chr \"NMF_\"   ##   ..@ jackstraw                 :Formal class 'JackStrawData' [package \"SeuratObject\"] with 4 slots   ##   .. .. ..@ empirical.p.values     : num[0 , 0 ]    ##   .. .. ..@ fake.reduction.scores  : num[0 , 0 ]    ##   .. .. ..@ empirical.p.values.full: num[0 , 0 ]    ##   .. .. ..@ overall.p.values       : num[0 , 0 ]    ##   ..@ misc                      :List of 1   ##   .. ..$ cv_data:'data.frame':   0 obs. of  0 variables   ``` <\/details>   `singlet` provides a helper function for quick exploration of GSEA results:   ```r GSEAHeatmap(pbmc3k, reduction = \"nmf\", max.terms.per.factor = 2)"},{"path":"/articles/Guided_Clustering_with_NMF.html","id":"cell-clustering","dir":"Articles","previous_headings":"","what":"Cell Clustering","title":"Guided Clustering with NMF","text":"pbmc3k dataset SeuratData ships clusters determined graph-based clustering PCA embedding, followed expert annotation based cluster marker genes. determine clusters graph-based clustering NMF embedding, compare PCA-guided clusters. NMF factors additive signals, can also visualize representation UMAP coordinates:  Compare composition NMF clusters Seurat PCA-determined clusterings:  Since significant correspondence PCA- NMF-guided clusters, can just transfer labels based majority overlap:  Compared PCA clustering (see Seurat vignette), NMF clustering completely resolves NK cells better resolves CD8 T-cells Memory CD4 T-cells, identify small cluster Dendritic Cells annotated Seurat vignette. results show PCA NMF can used achieve similar results cell clustering, NMF models interpretable capture information thus better cluster resolution.","code":"pbmc3k <- FindNeighbors(pbmc3k, dims = 1:ncol(pbmc3k@reductions$nmf), reduction = \"nmf\") %>%   FindClusters(resolution = 0.5) %>%   RunUMAP(reduction = \"nmf\", dims = 1:ncol(pbmc3k@reductions$nmf), verbose = FALSE) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ##  ## Number of nodes: 2638 ## Number of edges: 90649 ##  ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8894 ## Number of communities: 8 ## Elapsed time: 0 seconds FeaturePlot(pbmc3k, features = paste0(\"NMF_\", 1:6)) df <- data.frame(   \"nmf_clusters\" = pbmc3k@meta.data$seurat_clusters,   \"pca_clusters\" = pbmc3k@meta.data$seurat_annotations)  df <- df[!is.na(df$pca_clusters), ]  df <- df %>%    group_by(nmf_clusters) %>%    count(pca_clusters) %>%    mutate(freq = n / sum(n))  ggplot(df, aes(nmf_clusters, pca_clusters, size = freq, color = n)) +    geom_point() +    theme_bw() +    labs(x = \"NMF cluster\",         y = \"PCA cluster\",         size = \"proportion\\nof cluster\",         color = \"cells in\\nNMF cluster\") +    scale_color_viridis_c(option = \"D\") cluster_names <- df %>%    slice(which.max(n)) %>%    pull(pca_clusters)  levels(pbmc3k@meta.data$seurat_clusters) <- make.unique(as.vector(cluster_names))  DimPlot(pbmc3k, reduction = \"umap\", label = TRUE, group.by = \"seurat_clusters\", pt.size = 0.5) + NoLegend()"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Zach DeBruine. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"DeBruine Z (2022). singlet: singlet. R package version 0.0.99, https://github.com/zdebruine/singlet.","code":"@Manual{,   title = {singlet: singlet},   author = {Zach DeBruine},   year = {2022},   note = {R package version 0.0.99},   url = {https://github.com/zdebruine/singlet}, }"},{"path":"/index.html","id":"singlet-v0099","dir":"","previous_headings":"","what":"singlet","title":"singlet","text":"singlet actively developed (including documentation) still plenty known bugs, including LNMF function. Singlet brings fast Non-negative Matrix Factorization, new integration methods, every Seurat user.","code":""},{"path":"/index.html","id":"get-started","dir":"","previous_headings":"","what":"Get Started!","title":"singlet","text":"Planned vignettes: * Guided clustering tutorial SeuratData::pbmc3k dataset * Batch integration SeuratData::ifnb dataset (PBMC +/- stimulation) * Multi-modal integration SeuratData::bmcite","code":"install.packages(\"singlet\") library(singlet)"},{"path":"/index.html","id":"dimensional-reduction-with-nmf","dir":"","previous_headings":"","what":"Dimensional Reduction with NMF","title":"singlet","text":"Analyze single-cell assay NMF: NMF workflow NMF can almost anything PCA can , also: * imputes missing signal * always optimal rank (variance-stabilized data) * uses information assay (incl. “non-variable” genes) * robust across experiments * learns signatures transcriptional activity * colinear non-negative (interpretable), rather orthogonal signed (interpretable) Singlet internally provides fastest implementation NMF. Cross-validation can take minutes datasets ten thousand cells, extremely scalable runs excellently HPC nodes average laptops alike.","code":"library(singlet) library(Seurat) library(SeuratData) library(dplyr) library(cowplot) data(pbmc3k) pbmc3k <- NormalizeData(pbmc3k) set.seed(123) pbmc3k <- RunNMF(pbmc3k, k = seq(2, 20, 2), n_replicates = 1) pbmc3k <- RunUMAP(pbmc3k, reduction = \"nmf\", dims = 1:ncol(pbmc3k@reductions$nmf)) plot_grid(RankPlot(pbmc3k) + NoLegend(), DimPlot(pbmc3k) + NoLegend(), labels = \"auto\", ncol = 2)"},{"path":"/index.html","id":"integration-with-linked-nmf","dir":"","previous_headings":"","what":"Integration with Linked NMF","title":"singlet","text":"Learn integrated model information across modalities sample batches explore shared unique signals groups. unique shared features now completely separated, can run GSEA features better understand whether technical “batch effects” biological differences: Integration NMF Unlike Seurat anchor-based methods, integration LNMF preserves unique signals reduction thus allows understand shared unique signals different modalities/experiments. Unlike LIGER integrative NMF, integration LNMF completely uncouples shared unique signals one another assume shared unique signals given factor can mapped given sample weight (thus correspond linearly additively one another). LNMF? signals highly disparate, aligned. Work ongoing provide initializations LNMF can align even disparate signals. However, care taken properly interpret results avoid “forcing” much integration signals radically different.","code":"library(singlet) library(SeuratData) data(ifnb) ifnb <- NormalizeData(ifnb) ifnb <- RunNMF(ifnb, k = 30, split.by = \"stim\") ifnb <- RunLNMF(ifnb, split.by = \"stim\") jnmf_plot <- MetadataPlot(ifnb, split.by = \"stim\", reduction = \"nmf\") lnmf_plot <- MetadataPlot(ifnb, split.by = \"stim\", reduction = \"lnmf\") ifnb <- RunUMAP(ifnb, reduction = \"nmf\", dims = 1:ncol(ifnb@reductions$nmf), reduction.name = \"jnmf_all\") ifnb <- RunUMAP(ifnb, reduction = \"lnmf\", dims = 1:ncol(ifnb@reductions$lnmf), reduction.name = \"lnmf_all\") ifnb <- RunUMAP(ifnb, reduction = \"lnmf\", dims = GetSharedFactors(ifnb, split.by = \"stim\"), reduction.name = \"lnmf_shared\") selected_factors <-  which(rowSums(ifnb@reductions$lnmf@misc$link_matrix == 0) == 0) ifnb <- RunUMAP(ifnb, reduction = \"nmf\", dims = selected_factors, reduction.name = \"jnmf_shared\") plot_grid(jnmf_plot + ggtitle(\"joint NMF factor/batch weights\") + theme(legend.position = \"none\"), lnmf_plot + ggtitle(\"linked NMF factor/batch weights\") + theme(legend.position = \"none\"), get_legend(jnmf_plot), rel_widths = c(1, 1, 0.4), ncol = 3)  p_jnmf_umap <- DimPlot(ifnb, reduction = \"jnmf_all\", group.by = \"stim\") p_jnmf_shared_umap <- DimPlot(ifnb, reduction = \"jnmf_shared\", group.by = \"stim\") p_lnmf_all_umap <- DimPlot(ifnb, reduction = \"lnmf_all\", group.by = \"stim\") p_lnmf_shared_umap <- DimPlot(ifnb, reduction = \"lnmf_shared\", group.by = \"stim\")  plot_grid(plot_grid(   p_jnmf_umap + ggtitle(\"joint NMF\") + theme(legend.position = \"none\") + theme(legend.position = \"none\"),    p_jnmf_shared_umap + ggtitle(\"joint NMF, selected factors\") + theme(legend.position = \"none\"),    p_lnmf_all_umap + ggtitle(\"linked NMF, all factors\") + theme(legend.position = \"none\"),    p_lnmf_shared_umap + ggtitle(\"linked NMF, shared factors\") + theme(legend.position = \"none\"),    nrow = 2, ncol = 2  ), get_legend(p_jnmf_umap), ncol = 2, rel_widths = c(1, 0.2)) ifnb <- RunGSEA(ifnb, reduction = \"lnmf\", dims = GetUniqueFactors(ifnb, split.by = \"stim\")) GSEAHeatmap(ifnb, reduction = \"lnmf\")"},{"path":"/index.html","id":"ongoing-work","dir":"","previous_headings":"","what":"Ongoing Work","title":"singlet","text":"Singlet actively developed: new single-cell data class uses 10x less memory SCE Seurat (much faster) Full support Seurat SingleCellExperiment classes --core dimensional reduction NMF Regularization weighting enable discovery robust transcriptional signatures NMF Spatially-aware dimensional reduction Graph-regularization aligned joint NMF models initialize LNMF Integrative transfer learning linked Non-negative Least Squares projections","code":""},{"path":"/reference/GSEAHeatmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot GSEA results on a heatmap — GSEAHeatmap","title":"Plot GSEA results on a heatmap — GSEAHeatmap","text":"Plot top GSEA terms NMF factor heatmap","code":""},{"path":"/reference/GSEAHeatmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot GSEA results on a heatmap — GSEAHeatmap","text":"","code":"GSEAHeatmap(object, reduction = \"nmf\", max.terms.per.factor = 3)"},{"path":"/reference/GSEAHeatmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot GSEA results on a heatmap — GSEAHeatmap","text":"object Seurat object reduction dimensional reduction GSEA analysis performed max.terms.per.factor show number top terms factor","code":""},{"path":"/reference/GSEAHeatmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot GSEA results on a heatmap — GSEAHeatmap","text":"ggplot2 object","code":""},{"path":"/reference/MetadataSummary.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize contribution of sample groups to NMF factors — MetadataSummary","title":"Summarize contribution of sample groups to NMF factors — MetadataSummary","text":"Calculate mean weight samples discrete unique groups factor","code":""},{"path":"/reference/MetadataSummary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize contribution of sample groups to NMF factors — MetadataSummary","text":"","code":"MetadataSummary(h, factor_data, reorder = TRUE)  # S3 method for nmf_metadata_summary plot(x, ...)  MetadataHeatmap(x)"},{"path":"/reference/MetadataSummary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize contribution of sample groups to NMF factors — MetadataSummary","text":"h matrix giving factors rows samples columns factor_data factor length number columns h reorder sort results proportion group (uses hclust >2 groups) x result MetadataSummary ... implemented","code":""},{"path":"/reference/MetadataSummary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize contribution of sample groups to NMF factors — MetadataSummary","text":"data.frame mean weights sample group within factor class nmf_metadata_summary. Use plot method visualize.","code":""},{"path":"/reference/RankPlot.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot NMF cross-validation results — RankPlot.Seurat","title":"Plot NMF cross-validation results — RankPlot.Seurat","text":"Given NMF reduction multiple ranks, plot rank vs. test set reconstruction error determine optimal rank. S3 method Seurat runs singlet::RunNMF function.","code":""},{"path":"/reference/RankPlot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot NMF cross-validation results — RankPlot.Seurat","text":"","code":"# S3 method for Seurat RankPlot(object, reduction = \"nmf\")  RankPlot(object, reduction = \"nmf\")"},{"path":"/reference/RankPlot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot NMF cross-validation results — RankPlot.Seurat","text":"object Seurat object data.frame result RunNMF reduction name NMF reduction Seurat object (result RunNMF) multiple ranks computed.","code":""},{"path":"/reference/RankPlot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot NMF cross-validation results — RankPlot.Seurat","text":"ggplot2 object","code":""},{"path":"/reference/RunGSEA.Seurat.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Gene Set Enrichment Analysis — RunGSEA.Seurat","title":"Run Gene Set Enrichment Analysis — RunGSEA.Seurat","text":"Perform GSEA feature loadings reduction contained within Seurat object (.e. NMF factors) using MSIGDBR pathways manually provided pathways.","code":""},{"path":"/reference/RunGSEA.Seurat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Gene Set Enrichment Analysis — RunGSEA.Seurat","text":"","code":"RunGSEA.Seurat(object, reduction = \"nmf\")"},{"path":"/reference/RunGSEA.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Gene Set Enrichment Analysis on a Reduction — RunGSEA","title":"Run Gene Set Enrichment Analysis on a Reduction — RunGSEA","text":"Run GSEA identify gene sets enriched within NMF factors.","code":""},{"path":"/reference/RunGSEA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Gene Set Enrichment Analysis on a Reduction — RunGSEA","text":"","code":"RunGSEA(   object,   reduction = \"nmf\",   species = \"Homo sapiens\",   category = \"C5\",   min.size = 10,   max.size = 500,   dims = NULL,   verbose = TRUE,   padj.sig = 0.01 )"},{"path":"/reference/RunGSEA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Gene Set Enrichment Analysis on a Reduction — RunGSEA","text":"object Seurat object reduction dimensional reduction use species species load gene sets category msigdbr gene set category (.e. \"H\", \"C5\", etc.) min.size minimum number terms gene set max.size maximum number terms gene set dims factors reduction use, default NULL factors verbose print progress console padj.sig significance cutoff BH-adjusted p-values (default 0.01)","code":""},{"path":"/reference/RunGSEA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Gene Set Enrichment Analysis on a Reduction — RunGSEA","text":"Seurat object, GSEA information misc slot. BH-adj p-values -log10 scale.","code":""},{"path":"/reference/RunLNMF.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Linked NMF on a Seurat object — RunLNMF.Seurat","title":"Run Linked NMF on a Seurat object — RunLNMF.Seurat","text":"Run Linked Non-negative Matrix Factorization separate shared unique signals integration signature extraction. S3 method Seurat runs singlet::RunLNMF function.","code":""},{"path":"/reference/RunLNMF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Linked NMF on a Seurat object — RunLNMF.Seurat","text":"","code":"# S3 method for Seurat RunLNMF(   object,   split.by,   reduction.use = \"nmf\",   reduction.name = \"lnmf\",   reduction.key = \"LNMF_\",   verbose = TRUE,   link.cutoff = 0.5,   tol = 1e-04,   maxit = 100,   L1 = 0.01,   threads = 0,   precision = \"double\",   link.balance.tol = 0,   balance.maxit = 100,   link.balance.rate = 0.1,   ... )  RunLNMF(object, ...)  MetadataPlot(object, ...)  # S3 method for Seurat MetadataPlot(object, split.by, reduction = \"lnmf\", ...)  GetSharedFactors(object, split.by, reduction = \"lnmf\")  GetUniqueFactors(object, split.by, reduction = \"lnmf\")"},{"path":"/reference/RunLNMF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Linked NMF on a Seurat object — RunLNMF.Seurat","text":"object Seurat object split.attribute @metadata splitting. Data weighted group contributes equally LNMF model. reduction.use NMF reduction use initializing linked factorization. reduction.name name store resulting DimReduc object reduction.key key resulting DimReduc verbose print fitting progress console link.cutoff relative contribution samples given group factor falls link.cutoff, unlink factor. link.cutoff = 1 means factor must contribute exactly equally unlinked. tol tolerance fit (correlation distance model across consecutive iterations) maxit maximum number fitting iterations L1 L1/LASSO penalty increase sparsity model threads number threads use (0 = let OpenMP use available threads) precision \"double\" \"float\" numerical precision. \"float\" may faster, numerical instability may result iterations achieve desired tolerances. link.balance.tol relative change factor representation within sample groups balancing iterations call convergence. balance.maxit maximum number iterations balancing step link.balance.rate proportion difference current factor weight equal representation factors sample group target single iteration (default 0.1). ... implemented reduction reduction use metadata analysis link.balance initial linking step, weight shared factors dataset represented equally possible factor.","code":""},{"path":"/reference/RunLNMF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Linked NMF on a Seurat object — RunLNMF.Seurat","text":"Returns Seurat object NMF model stored reductions slot","code":""},{"path":"/reference/RunLNMF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run Linked NMF on a Seurat object — RunLNMF.Seurat","text":"Use set.seed() guarantee reproducibility!","code":""},{"path":[]},{"path":"/reference/RunNMF.Seurat.html","id":null,"dir":"Reference","previous_headings":"","what":"Run NMF on a Seurat object — RunNMF.Seurat","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"Run Non-negative Matrix Factorization dimensionality reduction rank determination cross-validation.","code":""},{"path":"/reference/RunNMF.Seurat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"","code":"# S3 method for Seurat RunNMF(   object,   assay = NULL,   reduction.name = \"nmf\",   reduction.key = \"NMF_\",   verbose = 2,   k = seq(2, 40, 2),   n_replicates = 1,   test.set.density = 0.05,   tol = 1e-04,   maxit = 100,   L1 = 0.01,   threads = 0,   split.by = NULL,   precision = \"float\" )"},{"path":"/reference/RunNMF.Seurat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"object Seurat object assay Assay use, defaults default assay first object reduction.name Name store resulting DimReduc object reduction.key Key resulting DimReduc verbose Level console output (0/FALSE, 1/TRUE, 2) k vector ranks fit, witholding test set n_replicates number replicates cross-validation test.set.density approximate density test set (default 0.05) tol tolerance fit (correlation distance model across consecutive iterations) maxit maximum number fitting iterations L1 L1/LASSO penalty increase sparsity model threads number threads use (0 = let OpenMP use available threads) split.Attribute @metadata splitting, applicable. Data weighted group contributes equally NMF model. precision \"double\" \"float\" numerical precision. \"float\" may faster, numerical instability may result iterations achieve desired tolerances.","code":""},{"path":"/reference/RunNMF.Seurat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"Returns Seurat object NMF model stored reductions slot","code":""},{"path":"/reference/RunNMF.Seurat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"Use set.seed() guarantee reproducibility!","code":""},{"path":[]},{"path":"/reference/RunNMF.html","id":null,"dir":"Reference","previous_headings":"","what":"Run NMF on a Seurat object — RunNMF.Seurat","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"Run Non-negative Matrix Factorization dimensionality reduction rank determination cross-validation.","code":""},{"path":"/reference/RunNMF.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"","code":"# S3 method for Seurat RunNMF(   object,   assay = NULL,   reduction.name = \"nmf\",   reduction.key = \"NMF_\",   verbose = 2,   k = seq(2, 40, 2),   n_replicates = 1,   test.set.density = 0.05,   tol = 1e-04,   maxit = 100,   L1 = 0.01,   threads = 0,   split.by = NULL,   precision = \"double\",   ... )  RunNMF(object, ...)"},{"path":"/reference/RunNMF.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"object Seurat object assay Assay use, defaults default assay first object reduction.name Name store resulting DimReduc object reduction.key Key resulting DimReduc verbose Level console output (0/FALSE, 1/TRUE, 2) k vector ranks fit, witholding test set n_replicates number replicates cross-validation test.set.density approximate density test set (default 0.05) tol tolerance fit (correlation distance model across consecutive iterations) maxit maximum number fitting iterations L1 L1/LASSO penalty increase sparsity model threads number threads use (0 = let OpenMP use available threads) split.Attribute @metadata splitting, applicable. Data weighted group contributes equally NMF model. precision \"double\" \"float\" numerical precision. \"float\" may faster, numerical instability may result iterations achieve desired tolerances. ... implemented","code":""},{"path":"/reference/RunNMF.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"Returns Seurat object NMF model stored reductions slot","code":""},{"path":"/reference/RunNMF.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run NMF on a Seurat object — RunNMF.Seurat","text":"Use set.seed() guarantee reproducibility!","code":""},{"path":[]},{"path":"/reference/cross_validate_nmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine best rank for NMF using cross-validation — cross_validate_nmf","title":"Determine best rank for NMF using cross-validation — cross_validate_nmf","text":"Find rank minimizes mean squared error test set reconstruction using cross-validation.","code":""},{"path":"/reference/cross_validate_nmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine best rank for NMF using cross-validation — cross_validate_nmf","text":"","code":"cross_validate_nmf(   A,   ranks,   n_replicates = 3,   tol = 1e-04,   maxit = 100,   verbose = 1,   L1 = 0.01,   threads = 0,   test_density = 0.05,   precision = \"float\" )  # S3 method for cross_validate_nmf_data plot(x, ...)"},{"path":"/reference/cross_validate_nmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine best rank for NMF using cross-validation — cross_validate_nmf","text":"sparse matrix (ideally variance-stabilized) data genes x cells (rows x columns) ranks vector ranks fit model compute test set reconstruction error n_replicates number random test sets tol tolerance fit (1e-5 publication quality, 1e-3 cross-validation) maxit maximum number iterations verbose verbosity level L1 L1/LASSO penalty increase sparsity model threads number threads parallelization across CPUs, 0 = use available threads test_density fraction values include test set precision \"float\" \"double\". High tolerance models may achievable \"float\" precision. x result cross_validate_nmf ... additional arguments (implemented)","code":""},{"path":"/reference/cross_validate_nmf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine best rank for NMF using cross-validation — cross_validate_nmf","text":"data.frame test set reconstruction error vs. rank class nmf_cross_validate_data. Use plot method visualize min compute optimal rank.","code":""},{"path":"/reference/run_linked_nmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Linked Non-negative Matrix Factorization — run_linked_nmf","title":"Run Linked Non-negative Matrix Factorization — run_linked_nmf","text":"Run LNMF, initialized NMF model, factors may \"linked\" certain samples.","code":""},{"path":"/reference/run_linked_nmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Linked Non-negative Matrix Factorization — run_linked_nmf","text":"","code":"run_linked_nmf(   A,   w,   link_h = NULL,   link_w = NULL,   tol = 1e-04,   maxit = 100,   verbose = TRUE,   L1 = 0.01,   threads = 0,   precision = \"float\" )"},{"path":"/reference/run_linked_nmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Linked Non-negative Matrix Factorization — run_linked_nmf","text":"sparse matrix (ideally variance-stabilized) data genes x cells (rows x columns) w initial matrix 'w', usually taken result run_nmf, dimensions nrow() x rank. link_h matrix giving linkage weight (usually range (0, 1)) dimensions rank x ncol(). link_w matrix giving linkage weight dimensions nrow() x rank. tol tolerance fit (1e-5 publication quality, 1e-3 cross-validation) maxit maximum number iterations verbose verbosity level L1 L1/LASSO penalty increase sparsity model threads number threads parallelization across CPUs, 0 = use available threads precision \"float\" \"double\". High tolerance models may achievable \"float\" precision.","code":""},{"path":"/reference/run_nmf.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Non-negative Matrix Factorization — run_nmf","title":"Run Non-negative Matrix Factorization — run_nmf","text":"Run NMF sparse matrix","code":""},{"path":"/reference/run_nmf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Non-negative Matrix Factorization — run_nmf","text":"","code":"run_nmf(   A,   rank,   tol = 1e-04,   maxit = 100,   verbose = TRUE,   L1 = 0.01,   threads = 0,   precision = \"float\" )"},{"path":"/reference/run_nmf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Non-negative Matrix Factorization — run_nmf","text":"sparse matrix (ideally variance-stabilized) data genes x cells (rows x columns) rank factorization rank tol tolerance fit (1e-5 publication quality, 1e-3 cross-validation) maxit maximum number iterations verbose verbosity level L1 L1/LASSO penalty increase sparsity model threads number threads parallelization across CPUs, 0 = use available threads precision \"float\" \"double\". High tolerance models may achievable \"float\" precision.","code":""},{"path":"/reference/singlet.html","id":null,"dir":"Reference","previous_headings":"","what":"Singlet — singlet","title":"Singlet — singlet","text":"Fast single-cell analysis non-negative dimensional reductions","code":""},{"path":"/reference/singlet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Singlet — singlet","text":"reasons use PCA. PCA fits missing signal, considers highly variable features, almost useless without graph-based analysis, requires centering scaling data, robust within experiments. Instead, use Non-negative Matrix Factorization (NMF). NMF imputes missing signal, learns models using features, everything PCA provides useful information , requires variance stabilization, robust across experiments. Singlet extremely fast NMF single-cell dimensional reduction integration. See vignettes get started.","code":""},{"path":"/reference/singlet.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Singlet — singlet","text":"Zach DeBruine","code":""}]
